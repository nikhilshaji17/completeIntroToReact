Hooks:
Allows interactivity and side effects in our code.

Note: Try to keep your functions pure, and avoid doing heavy rendering logic in your components.
	Why? React has its own logic to re-render components based on changes it notices.
	If a regularly used component has a lot of logic, it will take more time to render on change.

Anything that starts with use.. is a hook.

Never use Hooks inside conditionals. This would mess up React's rendering order.
Never use inside for, while loops, if conditions and so on.

NOTE: Vite is responsible for the jsx to js translation. So you'll have to build using Vite 
	for your program to work.

useState:
Allows you to control the state of your application
State = data that can change over time and make your component rerender.

useEffect:
Effects stand for side effects. 
Suppose you have a component that depends on external data, like a component that depends on an API
request. We would use useEffect here.

useEffect(fetchPizzaTypes(), [pizzaSize]); // This would only call fetchPizzaTypes() each time pizzaSize changes.
The second param decides how many times the first param/function is called. The second param is called your dependencies.

NOTE: useEffect always expects an undefined or a cleanup function as its return value. So we cannot use an async function
	(as it will return a Promise).

Use keys to keep track of rendering order. This way, you do not have to rerender the entire component, rather
	React can just reorder the things that need to be switched around.

StrictMode gives you warnings as to whether or not the features you are using are going to be 
	deprecated and so on.

Custom Hooks:
You can combine multiple hooks to create your own custom hook.
It is recommended to keep custom hooks as separate files to allow easy testing.
	If you component and code is simple however, it is acceptable to combine them.

